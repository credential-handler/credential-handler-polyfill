{"version":3,"sources":["webpack://WebCredentialHandler/webpack/universalModuleDefinition","webpack://WebCredentialHandler/webpack/bootstrap","webpack://WebCredentialHandler/./node_modules/web-request-rpc/utils.js","webpack://WebCredentialHandler/./node_modules/web-request-rpc/Client.js","webpack://WebCredentialHandler/./node_modules/web-request-rpc/Server.js","webpack://WebCredentialHandler/./node_modules/web-request-rpc/WebApp.js","webpack://WebCredentialHandler/./node_modules/web-request-rpc/WebAppWindow.js","webpack://WebCredentialHandler/./node_modules/web-request-rpc/WebAppContext.js","webpack://WebCredentialHandler/./CredentialEventProxy.js","webpack://WebCredentialHandler/./index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","RPC_ERRORS","ParseError","message","code","InvalidRequest","MethodNotFound","InvalidParams","InternalError","ServerError","parseUrl","url","base","undefined","location","href","URL","TypeError","includes","startsWith","parser","document","createElement","origin","protocol","host","port","hostname","pathname","isValidMessage","jsonrpc","id","createMessageListener","listener","handle","expectRequest","isHandlePromise","promise","then","h","e","source","Array","isArray","params","isValidRequest","data","error","isValidError","isValidResponse","RPC_CLIENT_CALL_TIMEOUT","Client_Client","[object Object]","this","_handle","_listener","_pending","Map","options","Error","parent","opener","pending","has","resolve","reject","cancelTimeout","result","err","constructor","DOMException","details","deserializeError","addEventListener","Injector","qualifiedMethodName","parameters","timeout","self","a","b","Math","random","toString","uuidv4","method","postMessage","Promise","timeoutId","setTimeout","delete","clearTimeout","set","removeEventListener","values","client","_apis","definition","functions","api","forEach","fn","async","send","arguments","Server_Server","ignoreUnknownApi","fqMethodName","rest","split","pop","join","destructureMethodName","sendMethodNotFound","response","apply","serializeError","assign","WebApp_WebApp","relyingOrigin","injector","server","_control","_connected","connect","listen","ready","close","show","hide","LOAD_WINDOW_TIMEOUT","WebAppWindow","iframe","windowControl","className","customize","visible","dialog","_ready","_private","_timeoutId","_readyPromise","_resolveReady","_rejectReady","isReady","destroy","parentNode","removeChild","contentWindow","style","visibility","applyStyle","position","top","left","width","height","display","margin","padding","border","background","color","box-sizing","overflow","z-index","appendChild","createTextNode","container","flex-direction","src","scrolling","flex-grow","preventDefault","body","webAppWindow","console","querySelector","_bodyOverflowStyle","showModal","element","WEB_APP_CONTEXT_LOAD_TIMEOUT","WebAppContext_WebAppContext","control","loaded","closed","PROXY_EVENT_TIMEOUT","CredentialEventProxy_CredentialEventProxy","super","resolveReceive","rejectReceive","event","resolveSend","rejectSend","respondWith","installHandler","CredentialManager","navigator","credentialsPolyfill","requestPermission","registration","getHandlerRegistration","log","uninstallHandler","CredentialHandlers","unregister","register","activateHandler","mediatorOrigin","store","CredentialHandler","receiveCredentialEvent","receive","type","dataType","appContext","windowOpen","openWindow","windowReady","createWindow","proxy","credentialRequestOptions","credentialRequestOrigin","credential","hintKey","createResponse","__webpack_exports__"],"mappings":"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","file":"web-credential-handler.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebCredentialHandler\"] = factory();\n\telse\n\t\troot[\"WebCredentialHandler\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*!\n * Utilities for Web Request RPC.\n *\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n/* global URL */\n'use strict';\n\nexport const RPC_ERRORS = {\n  ParseError: {\n    message: 'Parse error',\n    code: -32700\n  },\n  InvalidRequest: {\n    message: 'Invalid Request',\n    code: -32600\n  },\n  MethodNotFound: {\n    message: 'Method not found',\n    code: -32601\n  },\n  InvalidParams: {\n    message: 'Invalid params',\n    code: -32602\n  },\n  InternalError: {\n    message: 'Internal Error',\n    code: -32603\n  },\n  ServerError: {\n    message: 'Server error',\n    code: -32000\n  }\n};\n\nexport function parseUrl(url, base) {\n  if(base === undefined) {\n    base = window.location.href;\n  }\n\n  if(typeof URL === 'function') {\n    return new URL(url, base);\n  }\n\n  if(typeof url !== 'string') {\n    throw new TypeError('\"url\" must be a string.');\n  }\n\n  // FIXME: rudimentary relative URL resolution\n  if(!url.includes(':')) {\n    if(base.startsWith('http') && !url.startsWith('/')) {\n      url = base + '/' + url;\n    } else {\n      url = base + url;\n    }\n  }\n\n  // `URL` API not supported, use DOM to parse URL\n  const parser = document.createElement('a');\n  parser.href = url;\n  let origin = (parser.protocol || window.location.protocol) + '//';\n  if(parser.host) {\n    // use hostname when using default ports\n    // (IE adds always adds port to `parser.host`)\n    if((parser.protocol === 'http:' && parser.port === '80') ||\n      (parser.protocol === 'https:' && parser.port === '443')) {\n      origin += parser.hostname;\n    } else {\n      origin += parser.host;\n    }\n  } else {\n    origin += window.location.host;\n  }\n\n  // ensure pathname begins with `/`\n  let pathname = parser.pathname;\n  if(!pathname.startsWith('/')) {\n    pathname = '/' + pathname;\n  }\n\n  return {\n    // TODO: is this safe for general use on every browser that doesn't\n    //   support WHATWG URL?\n    host: parser.host || window.location.host,\n    hostname: parser.hostname,\n    origin: origin,\n    protocol: parser.protocol,\n    pathname: pathname\n  };\n}\n\nexport function originMatches(url, origin) {\n  return parseUrl(url, origin).origin === origin;\n}\n\n// https://gist.github.com/LeverOne/1308368\nexport function uuidv4(a,b) {\n  for(b=a='';a++<36;b+=a*51&52?(a^15?8^Math.random()*(a^20?16:4):4).toString(16):'-');return b;\n}\n\nexport function isValidOrigin(url, origin) {\n  if(!originMatches(url, origin)) {\n    throw new Error(\n      `Origin mismatch. Url \"${url}\" does not have an origin of \"${origin}\".`);\n  }\n}\n\nexport function isValidMessage(message) {\n  return (\n    message && typeof message === 'object' &&\n    message.jsonrpc === '2.0' &&\n    message.id && typeof message.id === 'string');\n}\n\nexport function isValidRequest(message) {\n  return isValidMessage(message) && Array.isArray(message.params);\n}\n\nexport function isValidResponse(message) {\n  return (\n    isValidMessage(message) &&\n    !!('result' in message ^ 'error' in message) &&\n    (!('error' in message) || isValidError(message.error)));\n}\n\nexport function isValidError(error) {\n  return (\n    error && typeof error === 'object' &&\n    typeof error.code === 'number' &&\n    typeof error.message === 'string');\n}\n\nexport function serializeError(error) {\n  const err = {\n    message: error.message\n  };\n  if(error.constructor.name !== 'Error') {\n    err.constructor = error.constructor.name;\n  }\n  if('name' in error) {\n    err.name = error.name;\n  }\n  if('code' in error) {\n    err.code = error.code;\n  } else {\n    err.code = RPC_ERRORS.ServerError.code;\n  }\n  if('details' in error) {\n    err.details = error.details;\n  }\n  return err;\n}\n\nexport function deserializeError(error) {\n  let err;\n  // special case known types, otherwise use generic Error\n  if(error.constructor === 'DOMException') {\n    err = new DOMException(error.message, error.name)\n    // ignore code, name will set it\n  } else {\n    err = new Error(error.message);\n    if('code' in error) {\n      err.code = error.code;\n    }\n  }\n  if(error.details) {\n    err.details = error.details;\n  }\n  return err;\n}\n\nexport function createMessageListener(\n  {listener, origin, handle, expectRequest}) {\n  // HACK: we can't just `Promise.resolve(handle)` because Chrome has\n  // a bug that throws an exception if the handle is cross domain\n  if(isHandlePromise(handle)) {\n    const promise = handle;\n    handle = false;\n    promise.then(h => handle = h);\n  }\n  return e => {\n    // ignore messages from a non-matching handle or origin\n    // or that don't follow the protocol\n    if(!(e.source === handle && e.origin === origin &&\n      ((expectRequest && isValidRequest(e.data)) ||\n        (!expectRequest && isValidResponse(e.data))))) {\n      return;\n    }\n    listener(e.data, e);\n  };\n}\n\nexport function destructureMethodName(fqMethodName) {\n  // fully-qualified method name is: `<api-name>.<method-name>`\n  // where `<api-name>` is all but the last dot-delimited segment and\n  // `<method-name>` is the last dot-delimited segment\n  let [name, ...rest] = fqMethodName.split('.');\n  const method = rest.pop();\n  name = [name, ...rest].join('.');\n  return {name, method};\n}\n\nexport function isHandlePromise(handle) {\n  try {\n    // HACK: we can't just `Promise.resolve(handle)` because Chrome has\n    // a bug that throws an exception if the handle is cross domain\n    return typeof handle.then === 'function';\n  } catch(e) {}\n  return false;\n}\n","/*!\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nimport * as utils from './utils.js';\n\n// 30 second default timeout\nconst RPC_CLIENT_CALL_TIMEOUT = 30000;\n\nexport class Client {\n  constructor() {\n    this.origin = null;\n    this._handle = null;\n    this._listener = null;\n    // all pending requests\n    this._pending = new Map();\n  }\n\n  /**\n   * Connects to a Web Request RPC server.\n   *\n   * The Promise will resolve to an RPC injector that can be used to get or\n   * define APIs to enable communication with the server.\n   *\n   * @param origin the origin to send messages to.\n   * @param options the options to use:\n   *          [handle] a handle to the window (or a Promise that resolves to\n   *            a handle) to send messages to\n   *            (defaults to `window.parent || window.opener`).\n   *\n   * @return a Promise that resolves to an RPC injector once connected.\n   */\n  async connect(origin, options) {\n    if(this._listener) {\n      throw new Error('Already connected.');\n    }\n\n    options = options || {};\n\n    // TODO: validate `origin` and `options.handle`\n    const self = this;\n    self.origin = utils.parseUrl(origin).origin;\n    self._handle = options.handle || window.parent || window.opener;\n\n    const pending = self._pending;\n    self._listener = utils.createMessageListener({\n      origin: self.origin,\n      handle: self._handle,\n      expectRequest: false,\n      listener: message => {\n        // ignore messages that have no matching, pending request\n        if(!pending.has(message.id)) {\n          return;\n        }\n\n        // resolve or reject Promise associated with message\n        const {resolve, reject, cancelTimeout} = pending.get(message.id);\n        cancelTimeout();\n        if('result' in message) {\n          return resolve(message.result);\n        }\n        reject(utils.deserializeError(message.error));\n      }\n    });\n    window.addEventListener('message', self._listener);\n\n    return new Injector(self);\n  }\n\n  /**\n   * Performs a RPC by sending a message to the Web Request RPC server and\n   * awaiting a response.\n   *\n   * @param qualifiedMethodName the fully-qualified name of the method to call.\n   * @param parameters the parameters for the method.\n   * @param options the options to use:\n   *          [timeout] a timeout, in milliseconds, for awaiting a response;\n   *            a non-positive timeout (<= 0) will cause an indefinite wait.\n   *\n   * @return a Promise that resolves to the result (or error) of the call.\n   */\n  async send(qualifiedMethodName, parameters, {\n    timeout = RPC_CLIENT_CALL_TIMEOUT\n  }) {\n    if(!this._listener) {\n      throw new Error('RPC client not connected.');\n    }\n\n    const self = this;\n\n    const message = {\n      jsonrpc: '2.0',\n      id: utils.uuidv4(),\n      method: qualifiedMethodName,\n      params: parameters\n    };\n\n    // HACK: we can't just `Promise.resolve(handle)` because Chrome has\n    // a bug that throws an exception if the handle is cross domain\n    if(utils.isHandlePromise(self._handle)) {\n      const handle = await self._handle;\n      handle.postMessage(message, self.origin);\n    } else {\n      self._handle.postMessage(message, self.origin);\n    }\n\n    // return Promise that will resolve once a response message has been\n    // received or once a timeout occurs\n    return new Promise((resolve, reject) => {\n      const pending = self._pending;\n      let cancelTimeout;\n      if(timeout > 0) {\n        const timeoutId = setTimeout(() => {\n          pending.delete(message.id);\n          reject(new Error('RPC call timed out.'));\n        }, timeout);\n        cancelTimeout = () => {\n          pending.delete(message.id);\n          clearTimeout(timeoutId);\n        };\n      } else {\n        cancelTimeout = () => {\n          pending.delete(message.id);\n        };\n      }\n      pending.set(message.id, {resolve, reject, cancelTimeout});\n    });\n  }\n\n  /**\n   * Disconnects from the remote Web Request RPC server and closes down this\n   * client.\n   */\n  close() {\n    if(this._listener) {\n      window.removeEventListener('message', this._listener);\n      this._handle = this.origin = this._listener = null;\n      // reject all pending calls\n      for(const value of this._pending.values()) {\n        value.reject(new Error('RPC client closed.'));\n      }\n      this._pending = new Map();\n    }\n  }\n}\n\nclass Injector {\n  constructor(client) {\n    this.client = client;\n    this._apis = new Map();\n  }\n\n  /**\n   * Defines a named API that will use an RPC client to implement its\n   * functions. Each of these functions will be asynchronous and return a\n   * Promise with the result from the RPC server.\n   *\n   * This function will return an interface with functions defined according\n   * to those provided in the given `definition`. The `name` parameter can be\n   * used to obtain this cached interface via `.get(name)`.\n   *\n   * @param name the name of the API.\n   * @param definition the definition for the API, including:\n   *          functions: an array of function names (as strings) or objects\n   *            containing: {name: <functionName>, options: <rpcClientOptions>}.\n   *\n   * @return an interface with the functions provided via `definition` that\n   *           will make RPC calls to an RPC server to provide their\n   *           implementation.\n   */\n  define(name, definition) {\n    if(!(name && typeof name === 'string')) {\n      throw new TypeError('`name` must be a non-empty string.');\n    }\n    // TODO: support Web IDL as a definition format?\n    if(!(definition && typeof definition === 'object' &&\n      Array.isArray(definition.functions))) {\n      throw new TypeError(\n        '`definition.function` must be an array of function names or ' +\n        'function definition objects to be defined.');\n    }\n\n    const self = this;\n    const api = {};\n\n    definition.functions.forEach(fn => {\n      if(typeof fn === 'string') {\n        fn = {name: fn, options: {}};\n      }\n      api[fn.name] = async function() {\n        return self.client.send(\n          name + '.' + fn.name, [...arguments], fn.options);\n      };\n    });\n\n    self._apis[name] = api;\n    return api;\n  }\n\n  /**\n   * Get a named API, defining it if necessary when a definition is provided.\n   *\n   * @param name the name of the API.\n   * @param [definition] the definition for the API; if the API is already\n   *          defined, this definition is ignored.\n   *\n   * @return the interface.\n   */\n  get(name, definition) {\n    const api = this._apis[name];\n    if(!api) {\n      if(definition) {\n        return this.define(name, definition);\n      }\n      throw new Error(`API \"${name}\" has not been defined.`);\n    }\n    return this._apis[name];\n  }\n}\n","/*!\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nimport * as utils from './utils.js';\n\nexport class Server {\n  constructor() {\n    this.origin = null;\n    this._handle = null;\n    this._apis = new Map();\n  }\n\n  /**\n   * Provides an implementation for a named API. All functions in the given\n   * API will be made callable via RPC clients connected to this server.\n   *\n   * @param name the name of the API.\n   * @param api the API to add.\n   */\n  define(name, api) {\n    if(!(name && typeof name === 'string')) {\n      throw new TypeError('`name` must be a non-empty string.');\n    }\n    if(!(api && api !== 'object')) {\n      throw new TypeError('`api` must be an object.');\n    }\n    if(name in this._apis) {\n      throw new Error(`The \"${name}\" API is already defined.`);\n    }\n\n    this._apis[name] = api;\n  }\n\n  /**\n   * Listens for RPC messages from clients from a particular origin and\n   * window handle and uses them to execute API calls based on predefined\n   * APIs.\n   *\n   * If messages are not from the given origin or window handle, they are\n   * ignored. If the messages refer to named APIs that have not been defined\n   * then an error message is sent in response. These error messages can\n   * be suppressed by using the `ignoreUnknownApi` option.\n   *\n   * If a message refers to an unknown method on a known named API, then an\n   * error message is sent in response.\n   *\n   * @param origin the origin to listen for.\n   * @param options the options to use:\n   *          [handle] a handle to the window (or a Promise that resolves to\n   *            a handle) to listen for messages from\n   *            (defaults to `window.parent || window.opener`).\n   *          [ignoreUnknownApi] `true` to ignore unknown API messages.\n   */\n  async listen(origin, options) {\n    if(this._listener) {\n      throw new Error('Already listening.');\n    }\n\n    options = options || {};\n\n    // TODO: validate `origin` and `options.handle`\n    const self = this;\n    self.origin = utils.parseUrl(origin).origin;\n    self._handle = options.handle || window.parent || window.opener;\n\n    const ignoreUnknownApi = (options.ignoreUnknownApi === 'true') || false;\n\n    self._listener = utils.createMessageListener({\n      origin: self.origin,\n      handle: self._handle,\n      expectRequest: true,\n      listener: message => {\n        const {name, method} = utils.destructureMethodName(message.method);\n        const api = self._apis[name];\n\n        // do not allow calling \"private\" methods (starts with `_`)\n        if(method && method.startsWith('_')) {\n          return sendMethodNotFound(self._handle, self.origin, message);\n        }\n\n        // API not found but ignore flag is on\n        if(!api && ignoreUnknownApi) {\n          // API not registered, ignore the message rather than raise error\n          return;\n        }\n\n        // no ignore flag and unknown API or unknown specific method\n        if(!api || typeof api[method] !== 'function') {\n          return sendMethodNotFound(self._handle, self.origin, message);\n        }\n\n        // API and specific function found\n        const fn = api[method];\n        (async () => {\n          const response = {\n            jsonrpc: '2.0',\n            id: message.id\n          };\n          try {\n            response.result = await fn.apply(api, message.params);\n          } catch(e) {\n            response.error = utils.serializeError(e);\n          }\n          // if server did not `close` while we waited for a response\n          if(self._handle) {\n            // HACK: we can't just `Promise.resolve(handle)` because Chrome has\n            // a bug that throws an exception if the handle is cross domain\n            if(utils.isHandlePromise(self._handle)) {\n              self._handle.then(h => h.postMessage(response, self.origin));\n            } else {\n              self._handle.postMessage(response, self.origin);\n            }\n          }\n        })();\n      }\n    });\n    window.addEventListener('message', self._listener);\n  }\n\n  close() {\n    if(this._listener) {\n      window.removeEventListener('message', this._listener);\n      this._handle = this.origin = this._listener = null;\n    }\n  }\n}\n\nfunction sendMethodNotFound(handle, origin, message) {\n  const response = {\n    jsonrpc: '2.0',\n    id: message.id,\n    error: Object.assign({}, utils.RPC_ERRORS.MethodNotFound)\n  };\n  // HACK: we can't just `Promise.resolve(handle)` because Chrome has\n  // a bug that throws an exception if the handle is cross domain\n  if(utils.isHandlePromise(handle)) {\n    return handle.then(h => h.postMessage(response, origin));\n  } else {\n    return handle.postMessage(response, origin);\n  }\n}\n","/*!\n * A WebApp is a remote application that runs in a WebAppContext.\n *\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nimport {Client} from './Client.js';\nimport {Server} from './Server.js';\nimport {parseUrl} from './utils.js';\n\nexport class WebApp {\n  constructor(relyingOrigin) {\n    // this is the origin that created the WebAppContext to run it in\n    // TODO: better name? `contextOrigin`?\n    this.relyingOrigin = parseUrl(relyingOrigin).origin;\n    this.client = null;\n    this.injector = null;\n    this.client = new Client();\n    this.server = new Server();\n\n    this._control = null;\n    this._connected = false;\n  }\n\n  /**\n   * Connects this WebApp to the relying origin that instantiated it. Once\n   * connected, the WebApp can start servicing calls from that origin.\n   *\n   * @return a Promise that resolves to an injector for creating custom client\n   *           APIs once the connection is ready.\n   */\n  async connect() {\n    this.injector = await this.client.connect(this.relyingOrigin);\n    this._connected = true;\n    this._control = this.injector.define('core.control', {\n      functions: ['ready', 'show', 'hide']\n    });\n    this.server.listen(this.relyingOrigin);\n    return this.injector;\n  }\n\n  /**\n   * Must be called after `connect` when this WebApp is ready to start\n   * receiving calls from the remote end.\n   */\n  async ready() {\n    if(!this._connected) {\n      throw new Error('WebApp not connected. Did you call \".connect()\"?');\n    }\n    await this._control.ready();\n    return this;\n  }\n\n  /**\n   * Closes this WebApp's connection to the relying origin.\n   */\n  close() {\n    if(this._connected) {\n      this.server.close();\n      this.client.close();\n      this._connected = false;\n    }\n  }\n\n  /**\n   * Shows the UI for this WebApp on the relying origin.\n   */\n  async show() {\n    if(!this._connected) {\n      throw new Error(\n        'Cannot \"show\" yet; not connected. Did you call \".connect()\"?');\n    }\n    return this._control.show();\n  }\n\n  /**\n   * Hides the UI for this WebApp on the relying origin.\n   */\n  async hide() {\n    if(!this._connected) {\n      throw new Error(\n        'Cannot \"hide\" yet; not connected. Did you call \".connect()?\"');\n    }\n    return this._control.hide();\n  }\n}\n","/*!\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\n// default timeout is 60 seconds\nconst LOAD_WINDOW_TIMEOUT = 60000;\n\n/**\n * Provides a window and API for remote Web applications. This API is typically\n * used by RPC WebApps that run in a WebAppContext to indicate when they are\n * ready and to show/hide their UI.\n */\nexport class WebAppWindow {\n  constructor(\n    url, {\n      timeout = LOAD_WINDOW_TIMEOUT,\n      handle,\n      iframe,\n      windowControl,\n      className = null,\n      customize = null\n    } = {}) {\n    this.visible = false;\n    this.dialog = null;\n    this.iframe = null;\n    this.handle = null;\n    this.windowControl = null;\n    this._ready = false;\n    this._private = {};\n    this._timeoutId = null;\n\n    // private to allow caller to track readiness\n    this._private._readyPromise = new Promise((resolve, reject) => {\n      // reject if timeout reached\n      this._timeoutId = setTimeout(\n        () => reject(new DOMException(\n          'Loading Web application window timed out.', 'TimeoutError')),\n        timeout);\n      this._private._resolveReady = value => {\n        clearTimeout(this.timeoutId);\n        this._timeoutId = null;\n        resolve(value);\n      };\n      this._private._rejectReady = err => {\n        clearTimeout(this.timeoutId);\n        this._timeoutId = null;\n        reject(err);\n      };\n    });\n    this._private.isReady = async () => {\n      return this._private._readyPromise;\n    };\n\n    // private to disallow destruction via client\n    this._private.destroy = () => {\n      // window not ready yet, but destroyed\n      if(this._timeoutId) {\n        this._private._rejectReady(new DOMException(\n          'Web application window closed before ready.', 'AbortError'));\n      }\n      if(this.dialog) {\n        this.dialog.parentNode.removeChild(this.dialog);\n        this.dialog = null;\n      }\n    };\n\n    if(iframe) {\n      // TODO: validate `iframe` option as much as possible\n      if(!(typeof iframe === 'object' && iframe.contentWindow)) {\n        throw new TypeError('`options.iframe` must be an iframe element.');\n      }\n      this.windowControl = {\n        handle: iframe.contentWindow,\n        show() {\n          iframe.style.visibility = 'visible';\n        },\n        hide() {\n          iframe.style.visibility = 'hidden';\n        }\n      };\n      this.iframe = iframe;\n      this.handle = this.iframe.contentWindow;\n      return;\n    }\n\n    if(windowControl) {\n      // TODO: validate `windowControl`\n      this.windowControl = windowControl;\n      this.handle = this.windowControl.handle;\n      return;\n    }\n\n    if(handle) {\n      // TODO: validate `handle`\n      this.handle = handle;\n      return;\n    }\n\n    if(customize) {\n      if(!typeof customize === 'function') {\n        throw new TypeError('`options.customize` must be a function.');\n      }\n    }\n\n    // create a top-level dialog overlay\n    this.dialog = document.createElement('dialog');\n    applyStyle(this.dialog, {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      display: 'none',\n      margin: 0,\n      padding: 0,\n      border: 'none',\n      background: 'transparent',\n      color: 'black',\n      'box-sizing': 'border-box',\n      overflow: 'hidden',\n      'z-index': 1000000\n    });\n    this.dialog.className = 'web-app-window';\n    if(typeof className === 'string') {\n      this.dialog.className = this.dialog.className + ' ' + className;\n    }\n\n    // ensure backdrop is transparent by default\n    const style = document.createElement('style');\n    style.appendChild(\n      document.createTextNode(`dialog.web-app-window::backdrop {\n        background-color: transparent;\n      }`));\n\n    // create flex container for iframe\n    this.container = document.createElement('div');\n    applyStyle(this.container, {\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      margin: 0,\n      padding: 0,\n      display: 'flex',\n      'flex-direction': 'column'\n    });\n    this.container.className = 'web-app-window-backdrop';\n\n    // create iframe\n    this.iframe = document.createElement('iframe');\n    this.iframe.src = url;\n    this.iframe.scrolling = 'no';\n    applyStyle(this.iframe, {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      border: 'none',\n      background: 'transparent',\n      overflow: 'hidden',\n      margin: 0,\n      padding: 0,\n      'flex-grow': 1\n    });\n\n    // assemble dialog\n    this.dialog.appendChild(style);\n    this.container.appendChild(this.iframe);\n    this.dialog.appendChild(this.container);\n\n    // handle cancel (user pressed escape)\n    this.dialog.addEventListener('cancel', e => {\n      e.preventDefault();\n      this.hide();\n    });\n\n    // attach to DOM\n    document.body.appendChild(this.dialog);\n    this.handle = this.iframe.contentWindow;\n\n    if(customize) {\n      try {\n        customize({\n          dialog: this.dialog,\n          container: this.container,\n          iframe: this.iframe,\n          webAppWindow: this\n        });\n      } catch(e) {\n        console.error(e);\n      }\n    }\n  }\n\n  /**\n   * Called by the client when it is ready to receive messages.\n   */\n  ready() {\n    this._ready = true;\n    this._private._resolveReady(true);\n  }\n\n  /**\n   * Called by the client when it wants to show UI.\n   */\n  show() {\n    if(!this.visible) {\n      this.visible = true;\n      // disable scrolling on body\n      const body = document.querySelector('body');\n      this._bodyOverflowStyle = body.style.overflow;\n      body.style.overflow = 'hidden';\n      if(this.dialog) {\n        this.dialog.style.display = 'block';\n        if(this.dialog.showModal) {\n          this.dialog.showModal();\n        }\n      } else if(this.windowControl.show) {\n        this.windowControl.show();\n      }\n    }\n  }\n\n  /**\n   * Called by the client when it wants to hide UI.\n   */\n  hide() {\n    if(this.visible) {\n      this.visible = false;\n      // restore `overflow` style on body\n      const body = document.querySelector('body');\n      if(this._bodyOverflowStyle) {\n        body.style.overflow = this._bodyOverflowStyle;\n      } else {\n        body.style.overflow = '';\n      }\n      if(this.dialog) {\n        this.dialog.style.display = 'none';\n        if(this.dialog.close) {\n          try {\n            this.dialog.close();\n          } catch(e) {\n            console.error(e);\n          }\n        }\n      } else if(this.windowControl.hide) {\n        this.windowControl.hide();\n      }\n    }\n  }\n}\n\nfunction applyStyle(element, style) {\n  for(const name in style) {\n    element.style[name] = style[name];\n  }\n}\n","/*!\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nimport {Client} from './Client.js';\nimport {Server} from './Server.js';\nimport {WebAppWindow} from './WebAppWindow.js';\nimport {parseUrl} from './utils.js';\n\n// 10 seconds\nconst WEB_APP_CONTEXT_LOAD_TIMEOUT = 10000;\n\nexport class WebAppContext {\n  constructor() {\n    this.client = new Client();\n    this.server = new Server();\n    this.injector = null;\n    this.control = null;\n    this.loaded = false;\n    this.closed = false;\n  }\n\n  /**\n   * Creates a window (or attaches to an existing one) that loads a page that\n   * is expected to understand the web request RPC protocol. This method\n   * returns a Promise that will resolve once the page uses RPC to indicate\n   * that it is ready to be communicated with or once a timeout occurs.\n   *\n   * The Promise will resolve to an RPC injector that can be used to get or\n   * define APIs to enable communication with the WebApp running in the\n   * WebAppContext.\n   *\n   * @param url the URL to the page to connect to.\n   * @param options the options to use:\n   *          [timeout] the timeout for waiting for the client to be ready.\n   *          [handle] a window handle to connect to; may be a Promise that\n   *            that resolves to a handle.\n   *          [iframe] an iframe element to connect to.\n   *          [windowControl] a window control interface to connect to.\n   *          [className] a className to assign to the window for CSS purposes.\n   *          [customize(options)] a function to customize the dialog that\n   *            loads the window after its construction.\n   *\n   * @return a Promise that resolves to an RPC injector once the window is\n   *           ready.\n   */\n  async createWindow(\n    url, {\n      timeout = WEB_APP_CONTEXT_LOAD_TIMEOUT,\n      iframe,\n      handle,\n      windowControl,\n      className,\n      customize\n    } = {}) {\n    // disallow loading the same WebAppContext more than once\n    if(this.loaded) {\n      throw new Error('AppContext already loaded.');\n    }\n    this.loaded = true;\n\n    // create control API for WebApp to call via its own RPC client\n    this.control = new WebAppWindow(url, {\n      timeout,\n      iframe,\n      handle,\n      windowControl,\n      className,\n      customize\n    });\n\n    // define control class; this enables the WebApp that is running in the\n    // WebAppContext to control its UI or close itself down\n    this.server.define('core.control', this.control);\n\n    // listen for calls from the window, ignoring calls to unknown APIs\n    // to allow those to be handled by other servers\n    const origin = parseUrl(url).origin;\n    this.server.listen(origin, {\n      handle: this.control.handle,\n      ignoreUnknownApi: true\n    });\n\n    // wait for control to be ready\n    await this.control._private.isReady();\n\n    // connect to the WebAppContext and return the injector\n    this.injector = await this.client.connect(origin, {\n      handle: this.control.handle\n    });\n    return this.injector;\n  }\n\n  close() {\n    if(!this.closed) {\n      this.closed = true;\n      this.control._private.destroy();\n      this.server.close();\n      this.client.close();\n    }\n  }\n}\n","/*!\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n/* global window */\n'use strict';\n\nimport {WebApp} from 'web-request-rpc';\n\nconst PROXY_EVENT_TIMEOUT = 60000;\n\nexport class CredentialEventProxy extends WebApp {\n  constructor() {\n    super(window.location.origin);\n  }\n\n  async receive() {\n    const self = this;\n    await self.connect();\n\n    // this promise resolves once the event is received\n    return new Promise((resolveReceive, rejectReceive) => {\n      const timeoutId = setTimeout(() => {\n        rejectReceive(new Error('Timed out waiting to receive event.'));\n      }, PROXY_EVENT_TIMEOUT);\n\n      self.server.define('credentialEventProxy', {\n        // called by credential handler to send event to UI window\n        async send(event) {\n          // event received, clear timeout\n          resolveReceive(event);\n          clearTimeout(timeoutId);\n\n          // this promise resolves when the promise that the UI passes\n          // to `event.respondWith` resolves\n          return new Promise((resolveSend, rejectSend) => {\n            event.respondWith = promise => {\n              try {\n                resolveSend(promise);\n              } catch(e) {\n                rejectSend(e);\n              }\n            };\n          });\n        }\n      });\n\n      self.ready();\n    });\n  }\n}\n","/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n/* global navigator */\n'use strict';\n\nimport {CredentialEventProxy} from './CredentialEventProxy.js';\nimport {WebAppContext} from 'web-request-rpc';\n\nexport async function installHandler({url}) {\n  const CredentialManager = navigator.credentialsPolyfill.CredentialManager;\n\n  // ensure permission has been granted to add a credential hint\n  const result = await CredentialManager.requestPermission();\n  // site asks permission to be a credential handler for the browser\n  if(result !== 'granted') {\n    throw new Error('Permission denied.');\n  }\n\n  const registration = await getHandlerRegistration({url});\n\n  console.log('registration:', registration)\n  if(!registration) {\n    throw new Error('Credential handler not registered.');\n  }\n\n  return registration;\n}\n\nexport async function uninstallHandler({url}) {\n  const CredentialHandlers = navigator.credentialsPolyfill.CredentialHandlers;\n  const CredentialManager = navigator.credentialsPolyfill.CredentialManager;\n\n  // ensure permission has been granted to add a credential hint\n  const result = await CredentialManager.requestPermission();\n  if(result !== 'granted') {\n    throw new Error('Permission denied.');\n  }\n\n  // unregister credential handler registration\n  await CredentialHandlers.unregister(url);\n}\n\n// url for client app to call when storing or getting credentials\nexport async function getHandlerRegistration({url}) {\n  const CredentialHandlers = navigator.credentialsPolyfill.CredentialHandlers;\n\n  let registration;\n  try {\n    // get credential handler registration\n    registration = await CredentialHandlers.register(url);\n  } catch(e) {\n    // ignore\n  }\n  return registration;\n}\n\n/**\n * Emulates activating a service worker.\n *\n * @param mediatorOrigin\n * @param {function} get\n * @param {function} store\n * @returns {Promise}\n */\nexport async function activateHandler({mediatorOrigin, get, store}) {\n  if(!(get || store)) {\n    throw new Error('\"get\" or \"store\" function(s) must be specified.');\n  }\n\n  const CredentialHandler = navigator.credentialsPolyfill.CredentialHandler;\n  const self = new CredentialHandler(mediatorOrigin);\n\n  if(get) {\n    if(typeof get !== 'function') {\n      throw new TypeError('\"get\" must be a function.');\n    }\n    self.addEventListener('credentialrequest', event => listener({event, get}));\n  }\n\n  if(store) {\n    if(typeof store !== 'function') {\n      throw new TypeError('\"store\" must be a function.');\n    }\n    self.addEventListener('credentialstore', event => listener({event, store}));\n  }\n\n  await self.connect();\n}\n\nexport async function receiveCredentialEvent() {\n  const proxy = new CredentialEventProxy();\n  return proxy.receive();\n}\n\nfunction listener({event, get, store}) {\n  event.respondWith(createResponse({event, get, store}));\n}\n\nasync function createResponse({event, get, store}) {\n  const result = await (get || store)({event});\n  if(!(result && typeof result === 'object')) {\n    throw new TypeError(\n      'Return value of \"get\" or \"store\" hook must be an object.');\n  }\n\n  if(result.type === 'response') {\n    return {dataType: result.dataType, data: result.data};\n  }\n\n  if(result.type === 'redirect') {\n    // create WebAppContext to run WebApp and connect to windowClient\n    const appContext = new WebAppContext();\n    const windowOpen = event.openWindow(result.url);\n    const windowReady = appContext.createWindow(result.url, {\n      handle: windowOpen,\n      // default to 10 minute timeout for loading other window on same site\n      // to allow for authentication pages and similar\n      timeout: 600000\n    });\n    await windowOpen;\n\n    // create proxy interface for making calls in WebApp\n    const injector = await windowReady;\n    const proxy = injector.get('credentialEventProxy', {\n      functions: [{name: 'send', options: {timeout: 0}}]\n    });\n\n    // WebApp running in window is ready; proxy event to it and return response\n    return proxy.send({\n      type: event.type,\n      credentialRequestOptions: event.credentialRequestOptions,\n      credentialRequestOrigin: event.credentialRequestOrigin,\n      credential: event.credential,\n      hintKey: event.hintKey\n    });\n  }\n\n  throw new Error(\n    'Return value of \"get\" or \"store\" must have a type of ' +\n    '\"response\" or \"redirect\".');\n}\n"],"sourceRoot":""}